esphome:
  name: poesoundmeter2
  friendly_name: POESoundMeter2
 
api:
  encryption:
    key: "USi4Ny4WB4+SegSwHPDQm8acz3cbRjTPr7Ew0RB8keg="
 
ota:
  - platform: esphome
    password: "e4f8b8741b6bd70933f033eebb838111"
 
esp32:
  board: esp32-poe-iso
  framework:
    type: arduino
 
ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk_mode: GPIO17_OUT
  phy_addr: 0
  power_pin: GPIO12
 
# Enable logging
logger:
 
external_components:
  - source: github://stas-sl/esphome-sound-level-meter
 
time:
  - platform: homeassistant
    id: esptime
 
i2c:
  sda: 2
  scl: 3
  frequency: 800kHz
 
i2s:
  bck_pin: 4                    #sck
  ws_pin: 5                    # ws
  din_pin: 36                   #SD  (Input Only Pin)
  sample_rate: 48000            # default: 48000
  bits_per_sample: 32           # default: 32
  dma_buf_count: 8              # default: 8
  dma_buf_len: 256              # default: 256
  use_apll: true                # default: false
  #L/R - Ground
  #GND - Ground
  #VDD - +3.3v
 
  # right shift samples.
  # for example if mic has 24 bit resolution, and
  # i2s configured as 32 bits, then audio data will be aligned left (MSB)
  # and LSB will be padded with zeros, so you might want to shift them right by 8 bits
  bits_shift: 8                 # default: 0
 
switch:
  - platform: gpio
    pin:    13
    name: "NoiseYellow"
    id: NYellow
  - platform: gpio
    pin:    16
    name: "NoiseRed"
    id: NRed
  - platform: gpio
    pin:    14
    name: "TempYellow"
    id: TYellow
  - platform: gpio
    pin:    32
    name: "TempRed"
    id: TRed
  - platform: gpio
    pin:    15
    name: "StatusLED"
    id: StatusLED
  #- platform: gpio
  #  pin:    0
  #  name: "Misc"
  # id: Misc
 
 
 
sound_level_meter:
  id: sound_level_meter1
 
  # update_interval specifies over which interval to aggregate audio data
  # you can specify default update_interval on top level, but you can also override
  # it further by specifying it on sensor level
  update_interval: 2s           # default: 60s
 
  # you can disable (turn off) component by default (on boot)
  # and turn it on later when needed via sound_level_meter.turn_on/toggle actions;
  # when used with switch it might conflict/being overriden by
  # switch state restoration logic, so you have to either disable it in
  # switch config and then is_on property here will have effect,
  # or completely rely on switch state restoration/initialization and
  # any value set here will be ignored
  is_on: true                   # default: true
 
  # buffer_size is in samples (not bytes), so for float data type
  # number of bytes will be buffer_size * 4
  buffer_size: 1024             # default: 1024
 
  # ignore audio data at startup for this long
  warmup_interval: 500ms        # default: 500ms
 
  # audio processing runs in a separate task, you can change its settings below
  task_stack_size: 4096         # default: 4096
  task_priority: 2              # default: 2
  task_core: 1                  # default: 1
 
  # see your mic datasheet to find sensitivity and reference SPL.
  # those are used to convert dB FS to db SPL
  mic_sensitivity: -26dB        # default: empty
  mic_sensitivity_ref: 94dB     # default: empty
  # additional offset if needed
  offset: 0dB                   # default: empty
 
  # for flexibility sensors are organized hierarchically into groups. each group
  # could have any number of filters, sensors and nested groups.
  # for examples if there is a top level group A with filter A and nested group B
  # with filter B, then for sensors inside group B filters A and then B will be
  # applied:
  # groups:
  #   # group A
  #   - filters:
  #       - filter A
  #     groups:
  #       # group B
  #       - filters:
  #           - filter B
  #         sensors:
  #           - sensor X
  groups:
    # group 1 (mic eq)
    - filters:
        # for now only SOS filter type is supported, see math/filter-design.ipynb
        # to learn how to create or convert other filter types to SOS
        - type: sos
          coeffs:
            # INMP441:
            #      b0            b1           b2          a1            a2
            - [ 1.0019784 , -1.9908513  , 0.9889158 , -1.9951786  , 0.99518436]
 
      # nested groups
      groups:
        # group 1.1 (no weighting)
        #- sensors:
            # 'eq' type sensor calculates Leq (average) sound level over specified period
           # - type: eq
           #   name: LZeq_1s
           #   id: LZeq_1s
           #   # you can override updated_interval specified on top level
           #   # individually per each sensor
           #   update_interval: 1s
 
            # you can have as many sensors of same type, but with different
            # other parameters (e.g. update_interval) as needed
           # - type: eq
           #   name: LZeq_1min
           #   id: LZeq_1min
           #   unit_of_measurement: dBZ
 
            # 'max' sensor type calculates Lmax with specified window_size.
            # for example, if update_interval is 60s and window_size is 1s
            # then it will calculate 60 Leq values for each second of audio data
            # and the result will be max of them
           # - type: max
           #   name: LZmax_1s_1min
           #   id: LZmax_1s_1min
           #   window_size: 1s
           #   unit_of_measurement: dBZ
 
            # same as 'max', but 'min'
           # - type: min
           #   name: LZmin_1s_1min
           #   id: LZmin_1s_1min
           #   window_size: 1s
           #   unit_of_measurement: dBZ
 
            # it finds max single sample over whole update_interval
           # - type: peak
           #   name: LZpeak_1min
           #   id: LZpeak_1min
           #   unit_of_measurement: dBZ
 
        # group 1.2 (A-weighting)
        - filters:
            # for now only SOS filter type is supported, see math/filter-design.ipynb
            # to learn how to create or convert other filter types to SOS
            - type: sos
              coeffs:
                # A-weighting:
                #       b0           b1            b2             a1            a2
                - [ 0.16999495 ,  0.741029   ,  0.52548885 , -0.11321865 , -0.056549273]
                - [ 1.         , -2.00027    ,  1.0002706  , -0.03433284 , -0.79215795 ]
                - [ 1.         , -0.709303   , -0.29071867 , -1.9822421  ,  0.9822986  ]
          sensors:
            - type: eq
              name: LAeq_1min
              id: LAeq_1min
              unit_of_measurement: dBA
              on_value_range:
              - below: 85.0
                then:
                  - switch.turn_off: NYellow
                  - switch.turn_off: NRed
              - above: 85.0
                below: 90.0
                then:
                  - switch.turn_on: NYellow
                  - switch.turn_off: NRed
              - above: 90.0
                then:
                  - switch.turn_off: NYellow
                  - switch.turn_on: NRed
            #- type: max
            #  name: LAmax_1s_1min
            #  id: LAmax_1s_1min
            #  window_size: 1s
            #  unit_of_measurement: dBA
            #- type: min
            #  name: LAmin_1s_1min
            #  id: LAmin_1s_1min
            #  window_size: 1s
            #  unit_of_measurement: dBA
            #- type: peak
            #  name: LApeak_1min
            #  id: LApeak_1min
            #  unit_of_measurement: dBA
 
        # group 1.3 (C-weighting)
        - filters:
            # for now only SOS filter type is supported, see math/filter-design.ipynb
            # to learn how to create or convert other filter types to SOS
            - type: sos
              coeffs:
                # C-weighting:
                #       b0             b1             b2             a1             a2
                - [-0.49651518  , -0.12296628  , -0.0076134163, -0.37165618   , 0.03453208  ]
                - [ 1.          ,  1.3294908   ,  0.44188643  ,  1.2312505    , 0.37899444  ]
                - [ 1.          , -2.          ,  1.          , -1.9946145    , 0.9946217   ]
               
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    lambda: |-
      it.printf(0, 15, id(font2), "%.1f dBA", id(LAeq_1min).state);
      // Print temperature in F and humidity in %
      it.printf(0, 35, id(font2), "%.1f F, %.0f %%", id(temp).state, id(humidity).state);
 
 
   
font:
  - file: 'gfonts://Roboto'
  # file: "fonts/roboto.ttf"
    id: font1
    size: 15
  - file: 'gfonts://Roboto'
  # file: "fonts/roboto.ttf"
    id: font2
    size: 20
 
sensor:
  - platform: dht
    model: DHT11
    pin: 33
    temperature:
      name: "Temperature"
      id: temp
      on_value_range:
        - below: 25.0
          then:
            - switch.turn_off: TYellow
            - switch.turn_off: TRed
        - above: 25.0
          below: 30.0
          then:
            - switch.turn_on: TYellow
            - switch.turn_off: TRed
        - above: 30.0
          then:
            - switch.turn_off: TYellow
            - switch.turn_on: TRed
      filters:
        - lambda: return x * (9.0/5.0) + 32.0;
      unit_of_measurement: "F"
    humidity:
      name: "Humidity"
      id: humidity
    update_interval: 60s

interval:
  - interval: 1s
    then:
      - if:
          condition:
            - lambda: 'return id(sound_level_meter1).is_on();'
          then:
            - switch.turn_on: StatusLED
            - delay: 500ms
            - switch.turn_off: StatusLED